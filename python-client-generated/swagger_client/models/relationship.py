# coding: utf-8

"""
    Client Master Data

    In the documentation below, you will receive detailed functional and technical specifications on the API DATEVconnect for Master Data.  **General information on dealing with fields administered as historical** A number of fields in the  master data are administered as \"historical\". This means that the existing content is not overwritten when the field is updated, but that the existing value remains in place, with a new value added that is valid from a date entered by the user.  Specifically, the following fields are administered as historical:  *Ressource 'addressees'* - short_names, - surnames, - company_names, - legal_form_ids  *Subordinate object 'detail'* - considerations, - denominations, - federal_states_of_natural_person, - job_titles, - marital_statuses, - codes_of_classification_of_economic_activities_2008, - descriptions_of_classification_of_economic_activities_2008, - mad_codes_of_classification_of_economic_activities_2008, - codes_of_classification_of_economic_activities_2003, - descriptions_of_classification_of_economic_activities_2003, - mad_codes_of_classification_of_economic_activities_2003, - countries_of_head_office, - distributions_of_profit, - enterprise_purposes, - federal_states_mad_of_legal_person, - federal_states_of_legal_person, - fiscal_years, - kind_of_register_courts, - locations_of_head_office, - names_of_register_court, - registered_company_names, - registration_numbers, - three_lined_company_names_first_line, - three_lined_company_names_second_line, - three_lined_company_names_third_line, - two_lined_company_names_first_line, - two_lined_company_names_second_line  These fields are shown as arrays, with their elements exhibiting the following structure: - value, - valid_from  This structure makes it possible to generate periods that indicate the validity date of a particular value in a value range.  This is illustrated by the following examples:  \"job_titles\": [   {\"value\":\"Müller\"},   {\"value\":\"Bäcker\", \"valid_from\":\"1995-04-01T00:00:00.000\"},   {\"value\":\"Metzger\", \"valid_from\":\"2001-07-01T00:00:00.000\"} ] In this example, the profession \"Müller\" (\"miller\") was valid until 03/31/1995. \"Bäcker\" (\"baker\") was valid from 04/01/1995 to 06/30/2001. The value \"Metzger\" (\"butcher\") is valid starting 07/01/2001.  For all the historically administered fields listed above, there is an additional field that indicates the current value of the value range (the value that is valid today/as of the system time). The syntactic structure of the property name is as follows: current_<*Property name of the historically administered field in the singular*>.  In the example above, the property name is \"current_job_title\" with the value \"Metzger\" (\"current_job_title\": \"Metzger\").  When writing fields administered as historical, please note that both properties have to be entered to prevent content from being lost. This can once again be illustrated using the example above:  Starting on 01/01/2010, the person is no longer employed as a butcher (\"Metzger\"), but now works as a landlord (\"Wirt\") in the hospitality industry. In order to save this information in the master data, the request has to be as follows:  ...  \"job_titles\": [   {\"value\":\"Müller\"},   {\"value\":\"Bäcker\", \"valid_from\":\"1995-04-01T00:00:00.000\"},   {\"value\":\"Metzger\", \"valid_from\":\"2001-07-01T00:00:00.000\"},   {\"value\": \"Wirt\", \"valid_from\": \"2010-01-01T00:00:00.000\"} ],  \"current_job_title\": \"Wirt\",  ...  If the property \"current_job_title\" had not been entered, but only the property \"job_titles\", then the current value (\"landlord\" in this example) would have been overwritten by a NULL value, as there would have been no explicit entry for the current value.  If, however, only the property \"current_job_title\" had been entered (i.e. without entering the property \"job_titles\"), then all historical values would have been overwritten. The result would have been the sole value of \"landlord\" without any time period set.  In summary, it can be said that the content of the property \"current_job_title\" overwrites the content of the valid array element of the property \"job_titles\".   # noqa: E501

    OpenAPI spec version: 1.0.1
    Contact: schnittstellenberatung@datev.de
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six

from swagger_client.configuration import Configuration


class Relationship(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'id': 'str',
        'abbreviation': 'str',
        'name': 'str',
        'standard': 'bool',
        'type_id': 'str',
        'has_addressee_id': 'str',
        'has_addressee_display_name': 'str',
        'has_addressee_type': 'str',
        'is_addressee_id': 'str',
        'is_addressee_display_name': 'str',
        'is_addressee_type': 'str'
    }

    attribute_map = {
        'id': 'id',
        'abbreviation': 'abbreviation',
        'name': 'name',
        'standard': 'standard',
        'type_id': 'type_id',
        'has_addressee_id': 'has_addressee_id',
        'has_addressee_display_name': 'has_addressee_display_name',
        'has_addressee_type': 'has_addressee_type',
        'is_addressee_id': 'is_addressee_id',
        'is_addressee_display_name': 'is_addressee_display_name',
        'is_addressee_type': 'is_addressee_type'
    }

    def __init__(self, id=None, abbreviation=None, name=None, standard=None, type_id=None, has_addressee_id=None, has_addressee_display_name=None, has_addressee_type=None, is_addressee_id=None, is_addressee_display_name=None, is_addressee_type=None, _configuration=None):  # noqa: E501
        """Relationship - a model defined in Swagger"""  # noqa: E501
        if _configuration is None:
            _configuration = Configuration()
        self._configuration = _configuration

        self._id = None
        self._abbreviation = None
        self._name = None
        self._standard = None
        self._type_id = None
        self._has_addressee_id = None
        self._has_addressee_display_name = None
        self._has_addressee_type = None
        self._is_addressee_id = None
        self._is_addressee_display_name = None
        self._is_addressee_type = None
        self.discriminator = None

        if id is not None:
            self.id = id
        if abbreviation is not None:
            self.abbreviation = abbreviation
        if name is not None:
            self.name = name
        if standard is not None:
            self.standard = standard
        if type_id is not None:
            self.type_id = type_id
        if has_addressee_id is not None:
            self.has_addressee_id = has_addressee_id
        if has_addressee_display_name is not None:
            self.has_addressee_display_name = has_addressee_display_name
        if has_addressee_type is not None:
            self.has_addressee_type = has_addressee_type
        if is_addressee_id is not None:
            self.is_addressee_id = is_addressee_id
        if is_addressee_display_name is not None:
            self.is_addressee_display_name = is_addressee_display_name
        if is_addressee_type is not None:
            self.is_addressee_type = is_addressee_type

    @property
    def id(self):
        """Gets the id of this Relationship.  # noqa: E501

        GUID of a relationship - internal identifier.   # noqa: E501

        :return: The id of this Relationship.  # noqa: E501
        :rtype: str
        """
        return self._id

    @id.setter
    def id(self, id):
        """Sets the id of this Relationship.

        GUID of a relationship - internal identifier.   # noqa: E501

        :param id: The id of this Relationship.  # noqa: E501
        :type: str
        """

        self._id = id

    @property
    def abbreviation(self):
        """Gets the abbreviation of this Relationship.  # noqa: E501

        Abbreviation of the relationship type.  # noqa: E501

        :return: The abbreviation of this Relationship.  # noqa: E501
        :rtype: str
        """
        return self._abbreviation

    @abbreviation.setter
    def abbreviation(self, abbreviation):
        """Sets the abbreviation of this Relationship.

        Abbreviation of the relationship type.  # noqa: E501

        :param abbreviation: The abbreviation of this Relationship.  # noqa: E501
        :type: str
        """
        if (self._configuration.client_side_validation and
                abbreviation is not None and len(abbreviation) > 10):
            raise ValueError("Invalid value for `abbreviation`, length must be less than or equal to `10`")  # noqa: E501

        self._abbreviation = abbreviation

    @property
    def name(self):
        """Gets the name of this Relationship.  # noqa: E501

        Name of the relationship type.  # noqa: E501

        :return: The name of this Relationship.  # noqa: E501
        :rtype: str
        """
        return self._name

    @name.setter
    def name(self, name):
        """Sets the name of this Relationship.

        Name of the relationship type.  # noqa: E501

        :param name: The name of this Relationship.  # noqa: E501
        :type: str
        """
        if (self._configuration.client_side_validation and
                name is not None and len(name) > 40):
            raise ValueError("Invalid value for `name`, length must be less than or equal to `40`")  # noqa: E501

        self._name = name

    @property
    def standard(self):
        """Gets the standard of this Relationship.  # noqa: E501

        Indicates whether the relationship type is a standard relationship type (to be supplied) or an individual relationship type (false).  # noqa: E501

        :return: The standard of this Relationship.  # noqa: E501
        :rtype: bool
        """
        return self._standard

    @standard.setter
    def standard(self, standard):
        """Sets the standard of this Relationship.

        Indicates whether the relationship type is a standard relationship type (to be supplied) or an individual relationship type (false).  # noqa: E501

        :param standard: The standard of this Relationship.  # noqa: E501
        :type: bool
        """

        self._standard = standard

    @property
    def type_id(self):
        """Gets the type_id of this Relationship.  # noqa: E501

        Id  of the relationship type.  # noqa: E501

        :return: The type_id of this Relationship.  # noqa: E501
        :rtype: str
        """
        return self._type_id

    @type_id.setter
    def type_id(self, type_id):
        """Sets the type_id of this Relationship.

        Id  of the relationship type.  # noqa: E501

        :param type_id: The type_id of this Relationship.  # noqa: E501
        :type: str
        """
        if (self._configuration.client_side_validation and
                type_id is not None and len(type_id) > 6):
            raise ValueError("Invalid value for `type_id`, length must be less than or equal to `6`")  # noqa: E501
        if (self._configuration.client_side_validation and
                type_id is not None and len(type_id) < 6):
            raise ValueError("Invalid value for `type_id`, length must be greater than or equal to `6`")  # noqa: E501

        self._type_id = type_id

    @property
    def has_addressee_id(self):
        """Gets the has_addressee_id of this Relationship.  # noqa: E501

        GUID of the has-addressee.<br>The has-addresse is the relationship partner who has for example shareholders or has children or has legal representatives.   # noqa: E501

        :return: The has_addressee_id of this Relationship.  # noqa: E501
        :rtype: str
        """
        return self._has_addressee_id

    @has_addressee_id.setter
    def has_addressee_id(self, has_addressee_id):
        """Sets the has_addressee_id of this Relationship.

        GUID of the has-addressee.<br>The has-addresse is the relationship partner who has for example shareholders or has children or has legal representatives.   # noqa: E501

        :param has_addressee_id: The has_addressee_id of this Relationship.  # noqa: E501
        :type: str
        """

        self._has_addressee_id = has_addressee_id

    @property
    def has_addressee_display_name(self):
        """Gets the has_addressee_display_name of this Relationship.  # noqa: E501

        Comprise the last and first name respectively the company name of the has-addressee.  # noqa: E501

        :return: The has_addressee_display_name of this Relationship.  # noqa: E501
        :rtype: str
        """
        return self._has_addressee_display_name

    @has_addressee_display_name.setter
    def has_addressee_display_name(self, has_addressee_display_name):
        """Sets the has_addressee_display_name of this Relationship.

        Comprise the last and first name respectively the company name of the has-addressee.  # noqa: E501

        :param has_addressee_display_name: The has_addressee_display_name of this Relationship.  # noqa: E501
        :type: str
        """
        if (self._configuration.client_side_validation and
                has_addressee_display_name is not None and len(has_addressee_display_name) > 72):
            raise ValueError("Invalid value for `has_addressee_display_name`, length must be less than or equal to `72`")  # noqa: E501

        self._has_addressee_display_name = has_addressee_display_name

    @property
    def has_addressee_type(self):
        """Gets the has_addressee_type of this Relationship.  # noqa: E501

        Indicates whether the has-addressee is a person or an enterprise.  # noqa: E501

        :return: The has_addressee_type of this Relationship.  # noqa: E501
        :rtype: str
        """
        return self._has_addressee_type

    @has_addressee_type.setter
    def has_addressee_type(self, has_addressee_type):
        """Sets the has_addressee_type of this Relationship.

        Indicates whether the has-addressee is a person or an enterprise.  # noqa: E501

        :param has_addressee_type: The has_addressee_type of this Relationship.  # noqa: E501
        :type: str
        """
        allowed_values = ["natural_person", "legal_person"]  # noqa: E501
        if (self._configuration.client_side_validation and
                has_addressee_type not in allowed_values):
            raise ValueError(
                "Invalid value for `has_addressee_type` ({0}), must be one of {1}"  # noqa: E501
                .format(has_addressee_type, allowed_values)
            )

        self._has_addressee_type = has_addressee_type

    @property
    def is_addressee_id(self):
        """Gets the is_addressee_id of this Relationship.  # noqa: E501

        GUID of the is-addressee.<br>The is-addresse is the relationship partner who is for example shareholder of a company or is a child or is a legal representative of a company.   # noqa: E501

        :return: The is_addressee_id of this Relationship.  # noqa: E501
        :rtype: str
        """
        return self._is_addressee_id

    @is_addressee_id.setter
    def is_addressee_id(self, is_addressee_id):
        """Sets the is_addressee_id of this Relationship.

        GUID of the is-addressee.<br>The is-addresse is the relationship partner who is for example shareholder of a company or is a child or is a legal representative of a company.   # noqa: E501

        :param is_addressee_id: The is_addressee_id of this Relationship.  # noqa: E501
        :type: str
        """

        self._is_addressee_id = is_addressee_id

    @property
    def is_addressee_display_name(self):
        """Gets the is_addressee_display_name of this Relationship.  # noqa: E501

        Comprise the last and first name respectively the company name of the is-addressee.  # noqa: E501

        :return: The is_addressee_display_name of this Relationship.  # noqa: E501
        :rtype: str
        """
        return self._is_addressee_display_name

    @is_addressee_display_name.setter
    def is_addressee_display_name(self, is_addressee_display_name):
        """Sets the is_addressee_display_name of this Relationship.

        Comprise the last and first name respectively the company name of the is-addressee.  # noqa: E501

        :param is_addressee_display_name: The is_addressee_display_name of this Relationship.  # noqa: E501
        :type: str
        """
        if (self._configuration.client_side_validation and
                is_addressee_display_name is not None and len(is_addressee_display_name) > 72):
            raise ValueError("Invalid value for `is_addressee_display_name`, length must be less than or equal to `72`")  # noqa: E501

        self._is_addressee_display_name = is_addressee_display_name

    @property
    def is_addressee_type(self):
        """Gets the is_addressee_type of this Relationship.  # noqa: E501

        Indicates whether the is-addressee is a person or an enterprise.  # noqa: E501

        :return: The is_addressee_type of this Relationship.  # noqa: E501
        :rtype: str
        """
        return self._is_addressee_type

    @is_addressee_type.setter
    def is_addressee_type(self, is_addressee_type):
        """Sets the is_addressee_type of this Relationship.

        Indicates whether the is-addressee is a person or an enterprise.  # noqa: E501

        :param is_addressee_type: The is_addressee_type of this Relationship.  # noqa: E501
        :type: str
        """
        allowed_values = ["natural_person", "legal_person"]  # noqa: E501
        if (self._configuration.client_side_validation and
                is_addressee_type not in allowed_values):
            raise ValueError(
                "Invalid value for `is_addressee_type` ({0}), must be one of {1}"  # noqa: E501
                .format(is_addressee_type, allowed_values)
            )

        self._is_addressee_type = is_addressee_type

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(Relationship, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, Relationship):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, Relationship):
            return True

        return self.to_dict() != other.to_dict()
